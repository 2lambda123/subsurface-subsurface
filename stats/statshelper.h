// SPDX-License-Identifier: GPL-2.0
// Helper functions to render the stats. Currently only
// contains a small template to create scene-items. This
// is for historical reasons to ease transition from QtCharts
// and might be removed.
#ifndef STATSHELPER_H
#define STATSHELPER_H

#include <memory>
#include <QGraphicsScene>
#include <QSGNode>

template <typename T, class... Args>
T *createItem(QGraphicsScene *scene, Args&&... args)
{
	T *res = new T(std::forward<Args>(args)...);
	scene->addItem(res);
	return res;
}

template <typename T, class... Args>
std::unique_ptr<T> createItemPtr(QGraphicsScene *scene, Args&&... args)
{
	return std::unique_ptr<T>(createItem<T>(scene, std::forward<Args>(args)...));
}

// In general, we want chart items to be hideable. For example to show/hide
// labels on demand. Very sadly, the QSG API is absolutely terrible with
// respect to temporarily disabling. Instead of simply having a flag,
// a QSGNode is queried using the "isSubtreeBlocked()" virtual function(!).
//
// Not only is this a slow operation performed on every single node, it
// also is often not possible to override this function: For improved
// performance, the documentation recommends to create QSG nodes via
// QQuickWindow. This provides nodes optimized for the actual hardware.
// However, this obviously means that these nodes cannot be derived from!
//
// In that case, there are two possibilities: Add a proxy node with an
// overridden "isSubtreeBlocked()" function or remove the node from the
// scene. The former was chosen here, because it is less complex.
//
// The following slightly cryptic templates are used to unify the two
// cases: The QSGNode is generated by our own code or the QSGNode is
// obtained from QQuickWindow.
//
// The "HideableQSGNode<Node>" template augments the QSGNode "Node"
// by a "setVisible()" function and overrides "isSubtreeBlocked()"
//
// The "QSGProxyNode<Node>" template is a QSGNode with a single
// child of type "Node".
//
// Thus, if the node can be created, use:
//	HideableQSGNode<NodeTypeThatCanBeCreated> node
// and if the node can only be obtained from QQuickWindow, use:
//	HideableQSGNode<QSGProxyNode<NodeThatCantBeCreated>> node
// The latter should obviously be typedef-ed.
//
// Yes, that's all horrible, but if nothing else it teaches us about
// composition.
template <typename Node>
class HideableQSGNode : public Node {
	bool hidden;
	bool isSubtreeBlocked() const override final;
public:
	template<class... Args>
	HideableQSGNode(bool visible, Args&&... args);
	void setVisible(bool visible);
};

template <typename Node>
class QSGProxyNode : public QSGNode {
public:
	std::unique_ptr<Node> node;
	QSGProxyNode(Node *node);
};

// Implementation detail of templates - move to serparate header file
template <typename Node>
QSGProxyNode<Node>::QSGProxyNode(Node *node) : node(node)
{
	appendChildNode(node);
}

template <typename Node>
bool HideableQSGNode<Node>::isSubtreeBlocked() const
{
	return hidden;
}

template <typename Node>
template<class... Args>
HideableQSGNode<Node>::HideableQSGNode(bool visible, Args&&... args) :
	Node(std::forward<Args>(args)...),
	hidden(!visible)
{
}

template <typename Node>
void HideableQSGNode<Node>::setVisible(bool visible)
{
	hidden = !visible;
}

#endif
